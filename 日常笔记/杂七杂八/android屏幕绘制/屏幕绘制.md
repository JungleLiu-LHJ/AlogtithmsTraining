# Android 屏幕绘制机制

### 屏幕渲染

* **CPU** 计算数据，把计算好的数据交给GPU
* **GPU**会图形数据进行渲染，渲染好放到buffer里面存起来
* **display**（屏幕）负责把buffer里的数据呈现在屏幕上



## VSYNC

* 刷新频率：屏幕每一秒内刷新画面的次数，取决于硬件的固定参数
* 帧速率（fps）：GPU在一秒内绘制的帧数，如一般手机是60HZ

> 屏幕撕裂：图像的绘制和读取使用的是用一个缓冲区。刷新频率和帧速率不匹配。如：屏幕刷新的上半部分是下一帧的，下半部分是上一帧的



## Double Buffer

让绘制和显示各自独立的图像缓冲区。GPU把完成的一帧图像数据写入到Back Buffer，显示器使用Frame Buffer，Back BUffer根据屏幕的刷新将图形数据copy到Frame Buffer。VSYNC信号负责调度从Back Buffer 到 Frame Buffer的交换操作，其实并不是真的copy，只是地址互换

![image-20210511162220060](.\image-20210511162220060.png)

问题：掉帧严重，如果一帧延误了会连续影响后面的几帧



## Triple Buffer

增加一个缓存区，防止双缓存出现的问题。

![image-20210511162531263](.\image-20210511162531263.png)

好处：

1. **缓解掉帧** :从上图 Double Buffer 和 Triple Buffer 的对比图可以看到，在这种情况下（出现连续主线程超时），三个 Buffer 的轮转有助于缓解掉帧出现的次数（从掉帧两次 -> 只掉帧一次）。，App 主线程超时不一定会导致掉帧，由于 Triple Buffer 的存在，部分 App 端的掉帧(主要是由于 GPU 导致)，到 SurfaceFlinger 这里未必是掉帧，这是看 Systrace 的时候需要注意的一个点
2. **减少主线程和渲染线程等待时间** ：双 Buffer 的轮转，App 主线程有时候必须要等待 SurfaceFlinger(消费者)释放 Buffer 后，才能获取 Buffer 进行生产，这时候就有个问题，现在大部分手机 SurfaceFlinger 和 App 同时收到 Vsync 信号，如果出现 App 主线程等待 SurfaceFlinger(消费者)释放 Buffer，那么势必会让 App 主线程的执行时间延后
3. **降低 GPU 和 SurfaceFlinger 瓶颈** ：这个比较好理解，双 Buffer 的时候，App 生产的 Buffer 必须要及时拿去让 GPU 进行渲染，然后 SurfaceFlinger 才能进行合成，一旦 GPU 超时，就很容易出现 SurfaceFlinger 无法及时合成而导致掉帧；在三个 Buffer 轮转的时候，App 生产的 Buffer 可以及早进入 BufferQueue，让 GPU 去进行渲染（因为不需要等待，就算这里积累了 2 个 Buffer，下下一帧才去合成，这里也会提早进行，而不是在真正使用之前去匆忙让 GPU 去渲染），另外 SurfaceFlinger 本身的负载如果比较大，三个 Buffer 轮转也会有效降低 dequeueBuffer 的等待时间





### Choreographer

android4.1出现，为了协同上层UI数据处理，就是管控出发UI处理显示数据的时机



Choreographer ：扮演 Android 渲染链路中承上启下的角色

* 承上：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等
* 启下：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync) .







